package de.neemann.digital.hdl.vhdl;

import de.neemann.digital.core.NodeException;
import de.neemann.digital.draw.elements.Circuit;
import de.neemann.digital.draw.elements.PinException;
import de.neemann.digital.draw.library.ElementLibrary;
import de.neemann.digital.draw.library.ElementNotFoundException;
import de.neemann.digital.hdl.model.*;
import de.neemann.digital.lang.Lang;

import java.io.*;
import java.util.HashSet;

/**
 * Exports the given circuit to vhdl
 */
public class VHDLExporter implements Closeable {

    private final PrintStream out;
    private final ElementLibrary library;
    private final ByteArrayOutputStream buffer;
    private final VHDLLibrary vhdlLibrary;

    /**
     * Creates a new exporter
     *
     * @param library the library
     */
    public VHDLExporter(ElementLibrary library) {
        this(library, new ByteArrayOutputStream());
    }

    /**
     * Creates a new exporter
     *
     * @param library the library
     * @param out     the output stream
     */
    public VHDLExporter(ElementLibrary library, OutputStream out) {
        this.library = library;
        if (out instanceof ByteArrayOutputStream)
            buffer = (ByteArrayOutputStream) out;
        else
            buffer = null;

        this.out = new PrintStream(out);

        vhdlLibrary = new VHDLLibrary();
    }

    /**
     * Writes the file to the given stream
     *
     * @param circuit the circuit to export
     * @return this for chained calls
     * @throws IOException IOException
     */
    public VHDLExporter export(Circuit circuit) throws IOException {
        out.println("-- auto generated by Digital\n");

        try {
            ModelList modelList = new ModelList(library);
            HDLModel model = new HDLModel(circuit, library, modelList).setName("main");
            export(model);

            for (HDLModel m : modelList) {
                out.println();
                out.println("-- " + m.getName());
                out.println();
                export(m);
            }

            vhdlLibrary.finish(out);

        } catch (HDLException | PinException | NodeException e) {
            e.setOrigin(circuit.getOrigin());
            throw new IOException(Lang.get("err_exporting_vhdl"), e);
        } catch (ElementNotFoundException e) {
            throw new IOException(Lang.get("err_exporting_vhdl"), e);
        }
        return this;
    }

    private void export(HDLModel model) throws PinException, HDLException, ElementNotFoundException, NodeException {
        writeHeader(out);
        out.println("entity " + model.getName() + " is");
        writePort(out, "  ", model.getPorts());
        out.println("end " + model.getName() + ";");

        out.println("\narchitecture " + model.getName() + "_arch of " + model.getName() + " is");

        HashSet<String> componentsWritten = new HashSet<>();
        for (HDLNode node : model) {
            String nodeName = getVhdlEntityName(node);
            if (!componentsWritten.contains(nodeName)) {
                writeComponent(node);
                componentsWritten.add(nodeName);
            }
        }
        out.println();
        for (Signal sig : model.getSignals()) {
            if (!sig.isPort()) {
                out.println("  signal " + sig.getName() + ": " + getType(sig.getBits()) + ";");
            }
        }

        out.println("begin");
        int g = 0;
        for (HDLNode node : model) {
            out.println("  gate" + (g++) + " : " + getVhdlEntityName(node));
            vhdlLibrary.writeGenericMap(out, node);
            writePortMap(node);
        }
        out.println("end " + model.getName() + "_arch;");
    }


    private void writePortMap(HDLNode node) throws HDLException {
        out.print("    port map ( ");
        Separator comma = new Separator(" , ");
        for (Port p : node.getPorts()) {
            if (p.getSignal() != null) {
                comma.check(out);
                if (p.getSignal().isPort())
                    out.print(p.getName() + " => " + p.getSignal().getName());
                else
                    out.print(p.getName() + " => " + p.getSignal().getName());
            }
        }
        out.println(" );");
    }

    private String getVhdlEntityName(HDLNode node) throws HDLException {
        if (node.isCustom())
            return node.getVisualElement().getElementName().replace('.', '_');
        else
            return vhdlLibrary.getName(node);
    }

    private void writeComponent(HDLNode node) throws ElementNotFoundException, NodeException, PinException, HDLException {
        out.println("\n  component " + getVhdlEntityName(node));
        vhdlLibrary.writePorts(out, node);
        out.println("  end component;");
    }

    static void writePort(PrintStream out, String blanks, Ports ports) throws HDLException {
        out.println(blanks + "port (");
        Separator semic = new Separator(";\n");
        for (Port p : ports) {
            semic.check(out);
            out.print(blanks + "  " + p.getName() + ": " + getDirection(p) + " " + getType(p.getBits()));
        }
        out.println(" );");
    }

    static void writeHeader(PrintStream out) {
        out.println("LIBRARY ieee;");
        out.println("USE ieee.std_logic_1164.all;\n");
    }

    /**
     * Returns the VHDL direction qualifier
     *
     * @param p the port
     * @return the direction
     * @throws HDLException HDLException
     */
    public static String getDirection(Port p) throws HDLException {
        switch (p.getDirection()) {
            case in:
                return "in";
            case out:
                return "out";
            default:
                throw new HDLException(Lang.get("err_vhdlUnknownPortType_N", p.getDirection().toString()));
        }
    }

    /**
     * returns the vhdl type
     *
     * @param bits the number of bits
     * @return the type
     * @throws HDLException HDLException
     */
    public static String getType(int bits) throws HDLException {
        if (bits == 0)
            throw new HDLException("bit number not available");
        if (bits == 1)
            return "std_logic";
        else
            return "std_logic_vector (" + (bits - 1) + " downto 0)";
    }

    @Override
    public String toString() {
        if (buffer != null) {
            out.flush();
            return buffer.toString();
        } else
            return "unknown";
    }

    @Override
    public void close() throws IOException {
        out.close();
    }

}
