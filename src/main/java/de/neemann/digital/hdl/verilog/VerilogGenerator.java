/*
 * Copyright (c) 2018 Ivan Deras
 * Use of this source code is governed by the GPL v3 license
 * that can be found in the LICENSE file.
 */
package de.neemann.digital.hdl.verilog;

import de.neemann.digital.core.NodeException;
import de.neemann.digital.draw.elements.Circuit;
import de.neemann.digital.draw.elements.PinException;
import de.neemann.digital.draw.library.ElementLibrary;
import de.neemann.digital.draw.library.ElementNotFoundException;
import de.neemann.digital.hdl.model.HDLException;
import de.neemann.digital.hdl.model.HDLInterface;
import de.neemann.digital.hdl.model.HDLModel;
import de.neemann.digital.hdl.model.HDLNode;
import de.neemann.digital.hdl.model.ModelList;
import de.neemann.digital.hdl.model.Port;
import de.neemann.digital.hdl.model.Ports;
import de.neemann.digital.hdl.model.Signal;
import de.neemann.digital.hdl.printer.CodePrinter;
import de.neemann.digital.hdl.printer.CodePrinterStr;
import de.neemann.digital.hdl.verilog.ir.stmt.VAlwaysBlock;
import de.neemann.digital.hdl.verilog.ir.stmt.VAssignStatement;
import de.neemann.digital.hdl.verilog.ir.stmt.VSCStatement;
import de.neemann.digital.hdl.verilog.ir.VIRNode;
import de.neemann.digital.hdl.verilog.ir.expr.VExpr;
import de.neemann.digital.hdl.verilog.ir.stmt.VStatement;
import de.neemann.digital.hdl.verilog.ir.VSignalDecl;
import de.neemann.digital.hdl.verilog.ir.stmt.VInstanceBlock;
import de.neemann.digital.hdl.vhdl.boards.BoardInterface;
import de.neemann.digital.hdl.vhdl.boards.BoardProvider;
import de.neemann.digital.lang.Lang;
import de.neemann.gui.LineBreaker;
import java.io.Closeable;
import java.io.File;
import java.io.IOException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Exports the given circuit to verilog
 *
 * @author ideras
 */
public class VerilogGenerator implements Closeable {
    private static final Logger LOGGER = LoggerFactory.getLogger(VerilogGenerator.class);
    private final CodePrinter out;
    private final ElementLibrary library;
    private final VerilogLibrary vlibrary;
    private VerilogTestBenchCreator testBenches;
    private int nodesWritten;
    private boolean omitClockDividers = false;

    /**
     * Creates a new exporter
     *
     * @param library the library
     * @throws IOException IOException
     */
    public VerilogGenerator(ElementLibrary library) throws IOException {
        this(library, new CodePrinterStr());
    }

    /**
     * Creates a new exporter
     *
     * @param library the library
     * @param out     the output stream
     */
    public VerilogGenerator(ElementLibrary library, CodePrinter out) {
        this.library = library;
        this.out = out;
        vlibrary = new VerilogLibrary(library);
    }

    /**
     * If called the integration of clock dividers and so on is omitted.
     * Mainly used for tests.
     *
     * @return this for chained calls
     */
    public VerilogGenerator omitClockDividers() {
        this.omitClockDividers = true;
        return this;
    }

    /**
     * Writes the file to the given stream
     *
     * @param circuit the circuit to export
     * @return this for chained calls
     * @throws IOException IOException
     */
    public VerilogGenerator export(Circuit circuit) throws IOException {
        out.println("/* ");
        out.println(" * Generated by Digital. Don't modify this file!");
        out.println(" * Any changes will be lost if this file is regenerated.");
        out.println(" */");

        try {
            BoardInterface board = BoardProvider.getInstance().getBoard(circuit);

            ModelList modelList = new ModelList(library);
            File f = out.getFile();
            String moduleName = getBaseName(f.getName());
            HDLModel model = new HDLModel(circuit, library, modelList).setName(moduleName);
            ModuleList moduleSet = new ModuleList();

            if (!omitClockDividers
                    && model.getClocks() != null
                    && model.getClocks().size() > 0
                    && board != null)
                board.getClockIntegrator().integrateClocks(model);

            export(model, moduleSet);

            out.println();
            for (HDLModel m : modelList) {
                out.println();
                out.println("// " + m.getName());
                out.println();
                if (m.getClocks() != null)
                    throw new HDLException(Lang.get("err_vhdlClockOnlyAllowedInRoot"));

                export(m, moduleSet);
                nodesWritten++;
            }

            for (String m : moduleSet.getModuleCodeList()) {
                out.print(m).println();
            }

            nodesWritten += moduleSet.size();

            File outFile = out.getFile();
            if (board != null && outFile != null)
                board.writeFiles(outFile, model);

            if (outFile != null) {
                testBenches = new VerilogTestBenchCreator(circuit, model);
                testBenches.write(out.getFile());
            }

            if (outFile != null)
                LOGGER.info("exported " + outFile + " (" + nodesWritten + " nodes)");
        } catch (HDLException | PinException | NodeException e) {
            e.setOrigin(circuit.getOrigin());
            throw new IOException(Lang.get("err_verilogExporting"), e);
        } catch (ElementNotFoundException e) {
            throw new IOException(Lang.get("err_verilogExporting"), e);
        }
        return this;
    }

    private void export(HDLModel model, ModuleList moduleSet) throws PinException, HDLException, ElementNotFoundException, NodeException, IOException {
        try {
            VerilogCodeBuilder vcb;

            if (moduleSet == null) {
                vcb = new VerilogCodeBuilder(model, library, vlibrary);
            } else {
                vcb = new VerilogCodeBuilder(model, moduleSet, library, vlibrary);
            }

            // Register the node output signals with the builder
            for (HDLNode node : model) {
                vcb.registerNodeOutputs(node);
            }

            // First pass visits all the elements and build the intermediate code representation.
            vcb.registerModelInputs();
            for (HDLNode node : model) {
                vcb.visit(node);
            }

            writeComment(out, model.getDescription(), model);

            out.print("module ").print(model.getName()).println(" (").inc();
            writePort(out, model.getPorts());
            out.dec().println("\n);");

            // map signals to output ports
            out.inc();
            for (Port p : model.getPorts().getOutputs()) {
                Signal s = p.getSignal();
                VIRNode codeIr = vcb.getSignalCodeIr(s);
                VExpr expr = codeIr.resolveToExpr(vcb);
                String exprCode = expr.getSourceCode(vcb);

                out.print("assign ").print(p.getName()).print(" = ").print(exprCode).print(";").println();

                /*if (codeIr.isExpr()) {
                    String exprCode = ((VExpr) codeIr).getSourceCode(vcb);
                    out.print("assign ").print(p.getName()).print(" = ").print(exprCode).print(";").println();
                } else if (codeIr.isStatement())  {
                    VStatement stmt = (VStatement) codeIr;

                    VExpr rightExpr = stmt.resolveToExpr(vcb);
                    out.print("assign ").print(p.getName()).print(" = ").print(rightExpr.getSourceCode(vcb)).println(";");
                } else {
                    throw new RuntimeException("BUG in the machine: Invalid code IR node in output signal. " + codeIr.getClass().toString());
                }*/
            }

            if (vcb.getDeclarations().size() > 0) {
                out.println();
                out.println("// signals declaration");

                for (VSignalDecl w : vcb.getDeclarations()) {
                    if (w.getType() == VSignalDecl.Type.REG)
                        out.print("reg ");
                    else
                        out.print("wire ");

                    if (w.getBits() > 1) {
                        out.print("[").print(w.getBits()-1).print(":0] ");
                    }
                    out.print(w.getName()).println(";");
                }
            }

            if (vcb.getStatements().size() > 0) {
                out.println();
                out.println("// statements");
                for (VStatement stmt : vcb.getStatements()) {

                    if (stmt instanceof VAssignStatement) {
                        out.print("assign ");
                        stmt.writeSourceCode(vcb, out);
                        out.println();
                    } else if (stmt instanceof VAlwaysBlock
                               || stmt instanceof VInstanceBlock
                               || stmt instanceof VSCStatement) {
                        stmt.writeSourceCode(vcb, out);
                        out.println();
                    } else {
                        out.println("always @ (*) begin");
                        out.inc();
                        stmt.writeSourceCode(vcb, out);
                        out.println();
                        out.dec();
                        out.println("end");
                    }
                }
            }

            if (vcb.getInitialStatements().size() > 0) {
                out.println("initial begin");
                out.inc();

                for (VStatement s : vcb.getInitialStatements()) {
                    s.writeSourceCode(vcb, out);
                    out.println();
                }
                out.dec();
                out.println("end");
            }

            out.dec().println("endmodule");

        } catch (HDLException e) {
            e.setOrigin(model.getOrigin());
            throw e;
        }

    }

    private String getVerilogComponentName(HDLNode node) throws HDLException {
        if (node.isCustom())
            return node.getHDLName();
        else
            return vlibrary.getName(node);
    }

    static void writeComment(CodePrinter out, String descr, HDLInterface entity) throws IOException {
        if (descr != null && descr.length() > 0)
            out.print("// ").print(new LineBreaker().setLineBreak("\n// ").breakLines(descr)).eol();


        Ports ports = entity.getPorts();
        boolean isPortComment = false;
        for (Port p : ports)
            if (p.getDescription() != null && p.getDescription().length() > 0) {
                isPortComment = true;
                break;
            }

        if (isPortComment) {
            out.println("//");
            boolean isInput = false;
            for (Port p : ports) {
                if (p.getDirection() == Port.Direction.in) {
                    if (!isInput) {
                        out.print("// Inputs:").eol();
                        isInput = true;
                    }
                    writePortComment(out, p);
                }
            }
            boolean isOutput = false;
            for (Port p : ports) {
                if (p.getDirection() == Port.Direction.out) {
                    if (!isOutput) {
                        out.print("// Outputs:").eol();
                        isOutput = true;
                    }
                    writePortComment(out, p);
                }
            }
        }
    }

    private static void writePortComment(CodePrinter out, Port p) throws IOException {
        out.print("//   ");
        out.println(new LineBreaker(p.getName(), 15, 70).setLineBreak("\n//   ").breakLines(p.getDescription()));
    }

    /**
     * Writes the given ports to the output
     *
     * @param out   the output stream
     * @param ports the ports
     * @throws HDLException HDLException
     * @throws IOException  IOException
     */
    public static void writePort(CodePrinter out, Ports ports) throws HDLException, IOException {
        boolean first = true;

        for (Port p : ports) {
            if (first) {
                first = false;
            } else {
                out.println(",");
            }
            out.print("  ").print(getPortDeclarationCode(p));
        }
    }

    /**
     * Returns the verilog port declaration code
     *
     * @param p the port
     * @return the generated verilog code
     * @throws HDLException HDLException
     */
    public static String getPortDeclarationCode(Port p) throws HDLException {
        String declCode;

        switch (p.getDirection()) {
            case out: declCode = "output "; break;
            case in: declCode = "input "; break;
            default:
                throw new HDLException(Lang.get("err_vhdlUnknownPortType_N", p.getDirection().toString()));
        }

        if (p.getBits() > 1)
            declCode += "[" + Integer.toString(p.getBits() - 1) + ":0] ";

        declCode += p.getName();

        return declCode;
    }

    /**
     * Returns the base name for a file
     *
     * @param fileName the file name
     * @return the base name
     */
    public static String getBaseName(String fileName) {
        int index = fileName.lastIndexOf('.');
        String baseName;

        if (index == -1) {
            baseName = fileName;
        } else {
            baseName = fileName.substring(0, index);
        }

        return baseName;
    }

    /**
     * @return the test bench creator
     */
    public VerilogTestBenchCreator getTestBenches() {
        return testBenches;
    }

    @Override
    public void close() throws IOException {
        out.close();
    }
}
