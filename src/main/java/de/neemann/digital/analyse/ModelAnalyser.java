package de.neemann.digital.analyse;

import de.neemann.digital.analyse.expression.BitSetter;
import de.neemann.digital.analyse.quinemc.BoolTableIntArray;
import de.neemann.digital.core.*;
import de.neemann.digital.core.flipflops.FlipflopD;
import de.neemann.digital.lang.Lang;

import java.util.ArrayList;
import java.util.List;

/**
 * Analyses a given model.
 * Calculates the truth table which is generated by the given model
 *
 * @author hneemann
 */
public class ModelAnalyser {

    private final Model model;
    private final ArrayList<Signal> inputs;
    private final ArrayList<Signal> outputs;
    private final int rows;

    /**
     * Creates a new instance
     *
     * @param model the model
     * @throws AnalyseException AnalyseException
     */
    public ModelAnalyser(Model model) throws AnalyseException {
        this.model = model;
        inputs = checkBinary(model.getInputs());
        outputs = checkBinary(model.getOutputs());

        for (Node n : model)
            if (n.hasState() && !(n instanceof FlipflopD))
                throw new AnalyseException(Lang.get("err_cannotAnalyse_N", n.getClass().getSimpleName()));

        int i = 0;
        List<FlipflopD> flipflops = model.findNode(FlipflopD.class);
        for (FlipflopD ff : flipflops) {
            ff.getDInput().removeObserver(ff); // turn off flipflop
            String label = ff.getLabel();
            if (label.length() == 0)
                throw new AnalyseException(Lang.get("err_DFlipflopWithoutALabel"));

            if (!label.endsWith("n"))
                label += "n";

            outputs.add(i++, new Signal(label + "+1", ff.getDInput()));

            ObservableValue q = ff.getOutputs().get(0);
            inputs.add(new Signal(label, q));

            ObservableValue notQ = ff.getOutputs().get(1);
            q.addObserver(() -> notQ.setValue(~q.getValue()));
        }

        if (inputs.size() == 0)
            throw new AnalyseException(Lang.get("err_analyseNoInputs"));
        if (inputs.size() > 12)
            throw new AnalyseException(Lang.get("err_toManyInputs_N", 12));
        if (outputs.size() == 0)
            throw new AnalyseException(Lang.get("err_analyseNoOutputs"));
        rows = 1 << inputs.size();
    }

    private ArrayList<Signal> checkBinary(ArrayList<Signal> list) throws AnalyseException {
        for (Signal s : list)
            if (s.getValue().getBits() != 1)
                throw new AnalyseException(Lang.get("err_analyseValue_N_IsNotBinary", s.getName()));
        return list;
    }

    /**
     * Analyses the circuit
     *
     * @return the generated truth table
     * @throws NodeException NodeException
     */
    public TruthTable analyse() throws NodeException {

        BitSetter bitsetter = new BitSetter(inputs.size()) {
            @Override
            public void setBit(int row, int bit, boolean value) {
                inputs.get(bit).getValue().setBool(value);
            }
        };

        TruthTable tt = new TruthTable();
        for (Signal s : inputs)
            tt.addVariable(s.getName());

        ArrayList<BoolTableIntArray> data = new ArrayList<>();
        for (Signal s : outputs) {
            BoolTableIntArray e = new BoolTableIntArray(rows);
            data.add(e);
            tt.addResult(s.getName(), e);
        }


        model.init();
        for (int row = 0; row < rows; row++) {
            bitsetter.fill(row);
            model.doStep();
            for (int i = 0; i < outputs.size(); i++) {
                data.get(i).set(row, outputs.get(i).getValue().getBool());
            }
        }
        return tt;
    }

}
