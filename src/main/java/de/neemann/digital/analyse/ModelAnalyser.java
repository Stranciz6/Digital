package de.neemann.digital.analyse;

import de.neemann.digital.analyse.expression.BitSetter;
import de.neemann.digital.analyse.quinemc.BoolTableIntArray;
import de.neemann.digital.core.*;
import de.neemann.digital.core.basic.And;
import de.neemann.digital.core.basic.Not;
import de.neemann.digital.core.basic.Or;
import de.neemann.digital.core.element.ElementAttributes;
import de.neemann.digital.core.flipflops.FlipflopD;
import de.neemann.digital.core.flipflops.FlipflopJK;
import de.neemann.digital.core.flipflops.FlipflopT;
import de.neemann.digital.core.wiring.Clock;
import de.neemann.digital.lang.Lang;

import java.util.ArrayList;
import java.util.List;

/**
 * Analyses a given model.
 * Calculates the truth table which is generated by the given model
 *
 * @author hneemann
 */
public class ModelAnalyser {
    private static final int MAX_INPUTS_ALLOWED = 12;

    private final Model model;
    private final ArrayList<Signal> inputs;
    private final ArrayList<Signal> outputs;
    private final int rows;

    /**
     * Creates a new instance
     *
     * @param model the model
     * @throws AnalyseException AnalyseException
     */
    public ModelAnalyser(Model model) throws AnalyseException {
        this.model = model;

        try {
            replaceJKFF();
            replaceTFF();
        } catch (NodeException e) {
            throw new AnalyseException(e);
        }

        inputs = checkBinary(model.getInputs());
        outputs = checkBinary(model.getOutputs());

        for (Node n : model)
            if (n.hasState() && !(n instanceof FlipflopD))
                throw new AnalyseException(Lang.get("err_cannotAnalyse_N", n.getClass().getSimpleName()));

        int i = 0;
        List<FlipflopD> flipflops = model.findNode(FlipflopD.class);
        for (FlipflopD ff : flipflops) {
            checkClock(ff);
            ff.getDInput().removeObserver(ff); // turn off flipflop
            String label = ff.getLabel();
            if (label.length() == 0)
                throw new AnalyseException(Lang.get("err_DFlipflopWithoutALabel"));

            if (!label.endsWith("n"))
                label += "n";

            outputs.add(i++, new Signal(label + "+1", ff.getDInput()));

            ObservableValue q = ff.getOutputs().get(0);
            inputs.add(new Signal(label, q));

            ObservableValue notQ = ff.getOutputs().get(1);
            q.addObserver(() -> notQ.setValue(~q.getValue()));
        }

        if (inputs.size() == 0)
            throw new AnalyseException(Lang.get("err_analyseNoInputs"));
        if (inputs.size() > MAX_INPUTS_ALLOWED)
            throw new AnalyseException(Lang.get("err_toManyInputs_max_N0_is_N1", MAX_INPUTS_ALLOWED, inputs.size()));
        if (outputs.size() == 0)
            throw new AnalyseException(Lang.get("err_analyseNoOutputs"));
        rows = 1 << inputs.size();
    }

    private void checkClock(Node node) throws AnalyseException {
        if (!getClock().hasObserver(node))
            throw new AnalyseException(Lang.get("err_ffNeedsToBeConnectedToClock"));
    }

    private ObservableValue getClock() throws AnalyseException {
        ArrayList<Clock> clocks = model.getClocks();
        if (clocks.size() != 1)
            throw new AnalyseException(Lang.get("err_aSingleClockNecessary"));
        return clocks.get(0).getClockOutput();
    }

    private ArrayList<Signal> checkBinary(ArrayList<Signal> list) throws AnalyseException {
        for (Signal s : list)
            if (s.getValue().getBits() != 1)
                throw new AnalyseException(Lang.get("err_analyseValue_N_IsNotBinary", s.getName()));
        return list;
    }

    /**
     * Analyses the circuit
     *
     * @return the generated truth table
     * @throws NodeException NodeException
     */
    public TruthTable analyse() throws NodeException {

        BitSetter bitsetter = new BitSetter(inputs.size()) {
            @Override
            public void setBit(int row, int bit, boolean value) {
                inputs.get(bit).getValue().setBool(value);
            }
        };

        TruthTable tt = new TruthTable();
        for (Signal s : inputs)
            tt.addVariable(s.getName());

        ArrayList<BoolTableIntArray> data = new ArrayList<>();
        for (Signal s : outputs) {
            BoolTableIntArray e = new BoolTableIntArray(rows);
            data.add(e);
            tt.addResult(s.getName(), e);
        }


        model.init();
        for (int row = 0; row < rows; row++) {
            bitsetter.fill(row);
            model.doStep();
            for (int i = 0; i < outputs.size(); i++) {
                data.get(i).set(row, outputs.get(i).getValue().getBool());
            }
        }
        return tt;
    }

    private void replaceJKFF() throws NodeException, AnalyseException {
        List<FlipflopJK> jkList = model.findNode(FlipflopJK.class);

        for (FlipflopJK jk : jkList) {
            checkClock(jk);

            // remove JK-ff from model
            model.removeNode(jk);
            jk.getClockVal().removeObserver(jk);
            jk.getjVal().removeObserver(jk);
            jk.getkVal().removeObserver(jk);

            // create d ff
            ObservableValue q = jk.getOutputs().get(0);
            ObservableValue qn = jk.getOutputs().get(1);
            FlipflopD d = new FlipflopD(jk.getLabel(), q, qn);

            And a1 = new And(new ElementAttributes());
            a1.setInputs(new ObservableValues(jk.getjVal(), qn));
            And a2 = new And(new ElementAttributes());
            Not nk = new Not(new ElementAttributes());
            nk.setInputs(jk.getkVal().asList());
            a2.setInputs(new ObservableValues(nk.getOutput(), q));

            Or or = new Or(new ElementAttributes());
            or.setInputs(new ObservableValues(a1.getOutput(), a2.getOutput()));

            d.setInputs(new ObservableValues(or.getOutputs().get(0), jk.getClockVal()));

            model.add(a1);
            model.add(a2);
            model.add(nk);
            model.add(or);
            model.add(d);
        }
    }

    private void replaceTFF() throws NodeException, AnalyseException {
        List<FlipflopT> jkList = model.findNode(FlipflopT.class);

        for (FlipflopT tff : jkList) {
            checkClock(tff);

            // remove T-ff from model
            model.removeNode(tff);
            tff.getClockVal().removeObserver(tff);

            // create d ff
            ObservableValue q = tff.getOutputs().get(0);
            ObservableValue qn = tff.getOutputs().get(1);
            FlipflopD d = new FlipflopD(tff.getLabel(), q, qn);

            d.setInputs(new ObservableValues(qn, getClock()));

            model.add(d);
        }
    }


}
